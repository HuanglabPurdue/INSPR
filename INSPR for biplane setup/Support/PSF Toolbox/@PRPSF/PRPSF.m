classdef PRPSF < handle
    % PRPSF class for gernerating phase retrieved pupil function and PSF
    %   create object: obj = PRPSF();
    %
    % PRPSF Properties (Input):
    %   CCDoffset - 
    %   FileDir - 
    %   FileName - 
    %   Gain - 
    %   IterationNum - 
    %   IterationNumK - 
    %   OTFratioSize - 
    %   PSFsize - 
    %   Pixelsize - 
    %   SubroiSize - 
    %   SaveDir - 
    %   ZernikeorderN - 
    %   Zstart - 
    %   Zend - 
    %   Zstep - 
    %   Zindstart - 
    %   Zindend - 
    %   Zindstep - 
    % 
    % PRPSF Properties (Output):
    %   PRstruct - out put structure of phase retrieval results
    %   PSFstruct - out put structure of various PSFs
    % 
    % PRPSF Methods:
    %   prepdata - converting ADU count to photon count and averaging over time dimension
    %   precomputeParam - generate images for k space operation
    %   datapreprocess - operate on BeadData, shift the bead to the center of the image and croped the image around the center into subregions defined by SubroiSize
    %   genMpsf - operate on Mpsf_subroi, generate normalized measured PSF that are used for phase
    %   saveObj - save PRPSF obj in SaveDir with a input saveName 
    %   calcrlb - calculate CRLB based on PSF model from phase retrieval results
    %   phaseretrieve - generate pupil function from measurend PSF using a phase retrieval algorithm
    %   findOTFparam - find SigmaX and SigmaY of a Gaussian filter for OTF rescale 
    %   findXYshift - find x,y shift of selected bead image using a 2D Gaussian fit to the most infocus PSF
    %   fitdefocus - find amount of defocus in z of the measured PSF
    %   genPRfigs - generate figures of phase retrieval result
    %   genZKresult - expand phase retrieved pupil function into zernike polynomials.
    %
    %   see also CalCRLB Zernike_Polynomials
    properties
        Zstart = -1; % start position of z, unit in micron
        Zend = 1; % end position of z, unit in micron
        Zstep = 0.4; % step size of z, unit in micron
        Zindstart = 1; % indices of the first z position used for phase retrieval
        Zindend = 6; % indices of the last z position used for phase retrieval
        Zindstep = 1; % increment in index used for phase retrieval
        Beadcenter; % pixel position of selected bead 
        BeadXYshift; % difference between Beadcenter and found bead position, unit is pixel
        BeadData; % bead images after converting ADU count to photon count and averaging over time dimension
        DatadimX; % x dimension of BeadData
        DatadimY; % y dimension of BeadData
        DatadimZ; % z dimension of BeadData
        PSFsize; % out put size of PSF
        SubroiSize; % subregion size of measured PSF used for phase retrieval
        Pixelsize; % pixel size at sample plane, unit is micron
        IterationNum; % iteration number of PR algorithm
        IterationNumK; % iteration number of PR algorithm after which the data preprocess will be changed 
        ZernikeorderN; % maximum order of Zernike coefficient, which is index n defined by Wyant ordering
        OTFratioSize; % subregion size of OTF images, which are used to calculate parameters of Gaussian filter used for OTF rescale
        % PRstruct - out put structure of phase retrieval results
        %   NA
        %   Lambda
        %   RefractiveIndex
        %   Pupil: phase retrieved pupil function
        %           phase: phase image
        %           uwphase: unwrapped phase if phase unwrapping is enabled
        %           mag: magnitude image
        %   Zernike_phase: coefficient of zernike polynomials representing the pupil phase
        %   Zernike_mag: coefficient of zernike polynomials representing the pupil phase
        %   Zernike_complex: coefficient of zernike polynomials representing the complex pupil function, the coefficients are complex numbers
        %   Fittedpupil: Zernike polynomial fitted pupil function
        %                 complex: pupil image with complex values
        %                 phase: phase image
        %                 mag: magnitude image
        %   SigmaX: sigmax of Gaussian filter for OTF rescale, unit is 1/micron in k space, the conversion to real space is 1/(2*pi*SigmaX), unit is micron
        %   SigmaY: sigmay of Gaussian filter for OTF rescale, unit is 1/micron in k space, the conversion to real space is 1/(2*pi*SigmaY), unit is micron
        %   Zernike_phaseinlambda: zernike coefficients describing the phase aberration, unit is lambda
        PRstruct; 
        % PSFstruct - out put structure of various PSFs
        %   PRpsf: PSF directly calculated from phase retrieved pupil function
        %   ZKpsf: PSF generated from Zernike polynomial
        %   Modpsf: PSF generated by applying a Gaussian filter on ZKpsf
        PSFstruct; 
        CCDoffset;% value(s) of CCD offset from gain calibration of the camera
        Gain;% value(s) of gain from gain calibration the camera
        FileDir;% file directory of the measured PSF data
        FileName;% file name of the measured PSF data
        SaveDir;% save directory of PRPSF object        
        Z;% object from Zernike_Polynomials class
        Enableunwrap; % 1: unwrap phase before zernike expansion, 0: phase is not unwrapped

        Zpos;  %the positions of Z images, added by Fan Xu 
    end
    
    properties (SetAccess = private, GetAccess = private)
        % precomputed images for k space operation
        PhiC; % phi coordinates based on BeadData, it's a image of DatadimX x DatadimY
        ZoC; % r coordinates based on BeadData, it's a image of DatadimX x DatadimY
        Phi; % phi coordinates out put PSF, it's a image of PSFsize x PSFsize
        k_r; % k_r coordinates of out put OTF, it's a image of PSFsize x PSFsize
        Zo; % r coordinates of out put PSF, it's a image of PSFsize x PSFsize
        NA_constrain; % a circular function defines the cut-off refrequency in Fourier space
    end
   %Fan Xu change 'SetAccess' to public 
    properties (SetAccess = public, GetAccess = public)
        Mpsf_subroi; % measured PSF after datapreprocess, which is a 3D image stack of SubroiSize x SubroiSize x Datadimz
        Mpsf_extend; % normalized measured PSF used for phase retrieval, which is a 3D image stack of PSFsize x PSFsize x Datadimz        
    end
    methods
        function obj=PRPSF

        end

        function prepdata(obj)
            % prepdata - converting ADU count to photon count and averaging
            % over time dimension.
            in = obj.BeadData;

            %Remove by Fan Xu, for inputing beads data
%             load(fullfile(obj.FileDir,obj.FileName),'dataset');    
% 
%             in=double(dataset);
%             in=squeeze(mean(in,3));
            in=(in-obj.CCDoffset)./obj.Gain;
%             f=min(in(:));
%             in=in-f+1e-4;
%             obj.BeadData=in;
            [obj.DatadimY,obj.DatadimX,obj.DatadimZ]=size(in);
            
            obj.Mpsf_subroi = obj.BeadData; %Edited by Fan Xu
        end
        function precomputeParam(obj)
            % precomputeParam - generate images for k space operation, and saved in
            % precomputed parameters.
            
            [XC,YC]=meshgrid(-obj.DatadimX/2:obj.DatadimX/2-1,-obj.DatadimY/2:obj.DatadimY/2-1);
            obj.PhiC=atan2(YC,XC);
            obj.ZoC=sqrt(XC.^2+YC.^2);
            
            [X,Y]=meshgrid(-obj.PSFsize/2:obj.PSFsize/2-1,-obj.PSFsize/2:obj.PSFsize/2-1);
            obj.Zo=sqrt(X.^2+Y.^2);
            scale=obj.PSFsize*obj.Pixelsize;
            obj.k_r=obj.Zo./scale;
            obj.Phi=atan2(Y,X);
            Freq_max=obj.PRstruct.NA/obj.PRstruct.Lambda;
            obj.NA_constrain=obj.k_r<Freq_max;

            % create Zernike_Polynomials object
            zk = Zernike_Polynomials();
            zk.Ordering = 'Wyant';
            zk.setN(obj.ZernikeorderN);
            zk.initialize();
            [Zrho, Ztheta, Zinit] = ...
               zk.params3_Zernike(obj.Phi, obj.k_r, obj.PRstruct.NA, obj.PRstruct.Lambda);
            zk.matrix_Z(Zrho, Ztheta, Zinit);
            obj.Z = zk;

        end
        
        function datapreprocess(obj)
            % datapreprocess - operate on BeadData, shift the bead to the center of the image and croped the
            % image around the center into subregions defined by SubroiSize. 
            %   The output is Mpsf_subroi. 
            realsize0=floor(obj.SubroiSize/2);
            realsize1=ceil(obj.SubroiSize/2);
            MpsfC=zeros(obj.SubroiSize,obj.SubroiSize,obj.DatadimZ);
            shiftxy=obj.Beadcenter-obj.BeadXYshift;
            for ii=1:obj.DatadimZ
                tmp=fftshift(ifft2(squeeze(obj.BeadData(:,:,ii))));
                shiftphase=-obj.ZoC./obj.DatadimX.*cos(obj.PhiC).*(obj.DatadimX/2-shiftxy(1)-1)-obj.ZoC./obj.DatadimY.*sin(obj.PhiC).*(obj.DatadimY/2-shiftxy(2)-1);
                tmp1=fft2(tmp.*exp(-2*pi.*shiftphase.*1i));
                startx=-realsize0+obj.DatadimX/2+1;endx=realsize1+obj.DatadimX/2;
                starty=-realsize0+obj.DatadimY/2+1;endy=realsize1+obj.DatadimY/2;
                tmp2=abs(tmp1(starty:endy,startx:endx));
                MpsfC(:,:,ii)=tmp2;
            end
            obj.Mpsf_subroi=MpsfC;
        end
        
        function genMpsf(obj)
            % genMpsf- operate on Mpsf_subroi, generate normalized measured PSF that are used for phase
            % retrieval. 
            %   The out put is Mpsf_extend. See paper 
            R1=obj.SubroiSize;    %change
            R=obj.PSFsize;
            N=obj.DatadimZ;
            
            [X1,Y1]=meshgrid(-R1/2:R1/2-1,-R1/2:R1/2-1);
            circle_tmp=sqrt(X1.^2+Y1.^2);
            circleF=circle_tmp;
            circleF(circleF<=R1/2-1)=1;
            circleF(circleF>R1/2-1)=0;
            if R==R1
                circleF=ones(R,R);
            end
            realsize0=floor(R1/2);
            realsize1=ceil(R1/2);
            starty=-realsize0+R/2+1;endy=realsize1+R/2;
            startx=-realsize0+R/2+1;endx=realsize1+R/2;
            MpsfL=zeros(R,R,N);
            % mask index
            index_mask1 = circle_tmp<=R1/2-1 & circle_tmp>=R1/2-3 & X1 >0 & Y1 > 0;
            index_mask2 = circle_tmp<=R1/2-1 & circle_tmp>=R1/2-3 & X1 <=0 & Y1 > 0;
            index_mask3 = circle_tmp<=R1/2-1 & circle_tmp>=R1/2-3 & X1 >0 & Y1 <= 0;
            index_mask4 = circle_tmp<=R1/2-1 & circle_tmp>=R1/2-3 & X1 <=0 & Y1 <= 0;
            for ii=1:N
                Mpsfo=obj.Mpsf_subroi(:,:,ii);  %change
                 Edge=[mean(Mpsfo(index_mask1))+1*std(Mpsfo(index_mask1)),mean(Mpsfo(index_mask2))+1*std(Mpsfo(index_mask2)),...
                     mean(Mpsfo(index_mask3))+1*std(Mpsfo(index_mask3)),mean(Mpsfo(index_mask4))+1*std(Mpsfo(index_mask4))];   %Edited by FX
                
                bg=max(Edge);

                Fig2=(Mpsfo-bg);
                Fig2 = Fig2 .* circleF; 
                Fig2(Fig2<=0)=0;
                tmp=zeros(R,R);
                tmp(starty:endy,startx:endx)=Fig2;
                Fig2=tmp;
                minimum0=0;
                Fig2(Fig2<=minimum0)=minimum0;
                MpsfL(:,:,ii)=Fig2./sum(sum(Fig2));
            end
            obj.Mpsf_extend=MpsfL;
        end
       
        function saveObj(obj,saveName)
            filename=obj.FileName;
            if isempty(obj.SaveDir)
                error('PRPSF:NoSaveDir','save directry is empty')
            else
                PRFileName=fullfile(obj.SaveDir,[filename(1:end-4) saveName '.mat']);
                save(PRFileName,'obj');
            end
        end
        
        function calcrlb(obj)
            % calcrlb - calculate CRLB based on PSF model from phase retrieval result. 
            %   It uses the CalCRLB class. It gives the CRLB in x,y,z
            %   at z positions defined by [obj.Zstart:0.1:obj.Zend], and at 
            %   given photon and background counts at 1000 and 2 respectively 
            %
            %   see also CalCRLB
            crobj=CalCRLB(obj.PRstruct,'pupil');
            z = obj.Zpos;
            Num=numel(z);
            crobj.Pixelsize=obj.Pixelsize;%micron
            crobj.Xpos=zeros(Num,1);
            crobj.Ypos=zeros(Num,1);
            crobj.Zpos=z';
            crobj.Photon=1000.*ones(Num,1);
            crobj.Bg=2.*ones(Num,1);
            crobj.Boxsize=16;
            crobj.Deltax=0.1;% pixel
            crobj.Deltaz=0.01;% micron
            
            crobj.prepInputparam();
            crobj.calcrlb();
            crobj.genfigs();
            
        end
        
        function calibrategain(obj)
        end
    end
    
end

